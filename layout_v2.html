<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endfield Factory Editor v2</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            overflow: hidden;
        }
        .app {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 240px;
            background: rgba(0,0,0,0.4);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-right: 1px solid #333;
            overflow-y: auto;
        }
        .sidebar h3 {
            color: #4fc3f7;
            font-size: 12px;
            margin: 8px 0 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }
        .tool-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border: 1px solid #444;
            background: rgba(255,255,255,0.05);
            color: #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s;
        }
        .tool-btn:hover { background: rgba(255,255,255,0.1); }
        .tool-btn.active { background: rgba(79,195,247,0.2); border-color: #4fc3f7; color: #4fc3f7; }
        .tool-btn .icon {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .tool-btn .info { margin-left: auto; color: #666; font-size: 10px; }

        /* Main area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
        }
        .toolbar button {
            padding: 6px 12px;
            border: 1px solid #444;
            background: rgba(255,255,255,0.08);
            color: #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .toolbar button:hover { background: rgba(255,255,255,0.15); }
        .toolbar button.primary { background: #2d5a5a; border-color: #4a8a8a; }
        .toolbar .spacer { flex: 1; }
        .toolbar .status { color: #888; font-size: 11px; }

        /* Canvas container */
        .canvas-container {
            flex: 1;
            overflow: auto;
            background: #16213e;
            position: relative;
        }
        #canvas {
            display: block;
            cursor: crosshair;
        }

        /* Stats bar */
        .stats {
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            display: flex;
            gap: 20px;
            font-size: 12px;
            border-top: 1px solid #333;
        }
        .stats span { color: #888; }
        .stats b { color: #ffd700; }
        .validation-error { color: #f44336; font-weight: bold; margin-left: 20px; }
        .validation-ok { color: #4caf50; margin-left: 20px; }

        /* Colors for facilities */
        .icon.furnace { background: #5a2d2d; }
        .icon.grinder { background: #5a5a2d; }
        .icon.shaping { background: #5a3d2d; }
        .icon.filling { background: #3d2d5a; }
        .icon.thickener { background: #2d5a5a; }
        .icon.planter { background: #2d5a2d; }
        .icon.seed_collector { background: #4a7a2d; }
        .icon.pylon { background: #7a2d7a; }
        .icon.storage { background: #5a5a3d; }
        .icon.drill { background: #5a4a2d; }
        .icon.pump { background: #2d4a5a; }
        .icon.conveyor { background: #666; }
        .icon.select { background: #444; }
        .icon.hub { background: #6a3030; }
    </style>
</head>
<body>
    <div class="app">
        <div class="sidebar">
            <h3>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</h3>
            <button class="tool-btn active" data-tool="select">
                <div class="icon select">‚úã</div>
                <span>–í—ã–±–æ—Ä / –£–¥–∞–ª–µ–Ω–∏–µ</span>
            </button>
            <button class="tool-btn" data-tool="conveyor">
                <div class="icon conveyor">‚Üí</div>
                <span>–ö–æ–Ω–≤–µ–π–µ—Ä</span>
                <span class="info">–õ–ö–ú —Ä–∏—Å—É–µ—Ç</span>
            </button>
            <button class="tool-btn" data-tool="hub">
                <div class="icon hub">‚ñ£</div>
                <span>–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –•–∞–±</span>
                <span class="info">9√ó9</span>
            </button>

            <h3>–û–±—Ä–∞–±–æ—Ç–∫–∞ (3√ó3)</h3>
            <button class="tool-btn" data-tool="furnace">
                <div class="icon furnace">‚óº</div>
                <span>–û—á–∏—Å—Ç–∫–∞</span>
                <span class="info">‚Üê ‚Üí</span>
            </button>
            <button class="tool-btn" data-tool="grinder">
                <div class="icon grinder">‚óº</div>
                <span>–ü–µ—Ä–µ–º–∞–ª—ã–≤–∞–Ω–∏–µ</span>
                <span class="info">‚Üê ‚Üí</span>
            </button>
            <button class="tool-btn" data-tool="shaping">
                <div class="icon shaping">‚óº</div>
                <span>–§–æ—Ä–º–æ–≤–∫–∞</span>
                <span class="info">‚Üê ‚Üí</span>
            </button>

            <h3>–ë–æ–ª—å—à–∏–µ —Å—Ç–∞–Ω–∫–∏</h3>
            <button class="tool-btn" data-tool="filling">
                <div class="icon filling">‚óº</div>
                <span>–ù–∞–ø–æ–ª–Ω–µ–Ω–∏–µ</span>
                <span class="info">6√ó4 ‚Üì‚Üì</span>
            </button>
            <button class="tool-btn" data-tool="thickener">
                <div class="icon thickener">‚óº</div>
                <span>–ò–∑–º–µ–ª—å—á–µ–Ω–∏–µ</span>
                <span class="info">6√ó4 ‚Üì‚Üì</span>
            </button>

            <h3>–§–µ—Ä–º–µ—Ä—Å—Ç–≤–æ (5√ó5)</h3>
            <button class="tool-btn" data-tool="planter">
                <div class="icon planter">‚óº</div>
                <span>–ü–æ—Å–∞–¥–∫–∞</span>
                <span class="info">‚Üë ‚Üì</span>
            </button>
            <button class="tool-btn" data-tool="seed_collector">
                <div class="icon seed_collector">‚óº</div>
                <span>–°–±–æ—Ä —Å–µ–º—è–Ω</span>
                <span class="info">‚Üë ‚Üì</span>
            </button>

            <h3>–ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞</h3>
            <button class="tool-btn" data-tool="pylon" title="–ù–µ–ª—å–∑—è —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –∫–æ–Ω–≤–µ–π–µ—Ä—ã –∏ —Å—Ç–∞–Ω–∫–∏!">
                <div class="icon pylon">‚ö°</div>
                <span>–ü–∏–ª–æ–Ω</span>
                <span class="info">2√ó2 ‚ö†Ô∏è</span>
            </button>
            <button class="tool-btn" data-tool="storage">
                <div class="icon storage">‚óº</div>
                <span>–•—Ä–∞–Ω–∏–ª–∏—â–µ</span>
                <span class="info">3√ó3</span>
            </button>
            <button class="tool-btn" data-tool="drill">
                <div class="icon drill">‚óº</div>
                <span>–ë—É—Ä</span>
                <span class="info">2√ó2</span>
            </button>
            <button class="tool-btn" data-tool="pump">
                <div class="icon pump">‚óº</div>
                <span>–ù–∞—Å–æ—Å</span>
                <span class="info">2√ó2</span>
            </button>
        </div>

        <div class="main">
            <div class="toolbar">
                <button onclick="undo()">‚Ü© –û—Ç–º–µ–Ω–∞</button>
                <button onclick="redo()">‚Ü™ –ü–æ–≤—Ç–æ—Ä</button>
                <button onclick="clearAll()">üóë –û—á–∏—Å—Ç–∏—Ç—å</button>
                <span style="color:#555">|</span>
                <button onclick="zoomIn()">üîç+</button>
                <button onclick="zoomOut()">üîç-</button>
                <span id="zoomLabel" class="status">100%</span>
                <span class="spacer"></span>
                <button class="primary" onclick="exportJSON()">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                <button onclick="importJSON()">üì• –ò–º–ø–æ—Ä—Ç</button>
                <button id="flagsBtn" onclick="toggleTileFlags()">üè∑Ô∏è –ö–æ–¥—ã</button>
                <button id="validateBtn" onclick="runValidation()" style="background:#c44;">üîç –í–∞–ª–∏–¥–∞—Ü–∏—è</button>
                <span id="rotationLabel" class="status" style="color:#ffd700">R: 0¬∞</span>
                <span class="status">–õ–ö–ú - —Å—Ç–∞–≤–∏—Ç—å | –ü–ö–ú - —É–¥–∞–ª—è—Ç—å | R - –ø–æ–≤–æ—Ä–æ—Ç</span>
            </div>

            <div class="canvas-container" id="container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="stats">
                <div><span>–°—Ç–∞–Ω–∫–æ–≤:</span> <b id="statFacilities">0</b></div>
                <div><span>–ö–æ–Ω–≤–µ–π–µ—Ä–æ–≤:</span> <b id="statConveyors">0</b></div>
                <div><span>–ü–∏–ª–æ–Ω–æ–≤:</span> <b id="statPylons">0</b></div>
                <div><span>–ü–ª–æ—â–∞–¥—å:</span> <b id="statArea">0</b> / 3519</div>
                <div id="validationMsg" class="validation-ok"></div>
            </div>
            <div id="validationPanel" style="display:none; background:#1a1a2e; border:1px solid #444; border-radius:8px; padding:10px; margin-top:10px; max-height:300px; overflow-y:auto;">
                <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                    <b style="color:#fff;">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>
                    <button onclick="document.getElementById('validationPanel').style.display='none'" style="padding:2px 8px;">‚úï</button>
                </div>
                <div id="validationResults" style="font-size:12px; font-family:monospace;"></div>
            </div>
        </div>
    </div>

    <script>
    // === CONSTANTS ===
    const GRID_SIZE = 60;
    const BASE_CELL_SIZE = 12;

    const FACILITIES = {
        hub:            { w: 9, h: 9, name: '–•–∞–±',           color: '#6a3030', isHub: true },
        furnace:        { w: 3, h: 3, name: '–û—á–∏—Å—Ç–∫–∞',      color: '#5a2d2d', inputSide: 'left', outputSide: 'right' },
        grinder:        { w: 3, h: 3, name: '–ü–µ—Ä–µ–º–∞–ª—ã–≤–∞–Ω–∏–µ', color: '#5a5a2d', inputSide: 'left', outputSide: 'right' },
        shaping:        { w: 3, h: 3, name: '–§–æ—Ä–º–æ–≤–∫–∞',      color: '#5a3d2d', inputSide: 'left', outputSide: 'right' },
        filling:        { w: 6, h: 4, name: '–ù–∞–ø–æ–ª–Ω–µ–Ω–∏–µ',    color: '#3d2d5a', inputSide: 'top',  outputSide: 'bottom' },
        thickener:      { w: 6, h: 4, name: '–ò–∑–º–µ–ª—å—á–µ–Ω–∏–µ',   color: '#2d5a5a', inputSide: 'top',  outputSide: 'bottom' },
        planter:        { w: 5, h: 5, name: '–ü–æ—Å–∞–¥–∫–∞',       color: '#2d5a2d', inputSide: 'top',  outputSide: 'bottom' },
        seed_collector: { w: 5, h: 5, name: '–°–µ–º–µ–Ω–∞',        color: '#4a7a2d', inputSide: 'top',  outputSide: 'bottom' },
        pylon:          { w: 2, h: 2, name: '–ü–∏–ª–æ–Ω',         color: '#7a2d7a', coverage: 12 },
        storage:        { w: 3, h: 3, name: '–•—Ä–∞–Ω–∏–ª–∏—â–µ',     color: '#5a5a3d', inputSide: 'left', outputSide: 'right' },
        drill:          { w: 2, h: 2, name: '–ë—É—Ä',           color: '#5a4a2d', outputSide: 'any' },
        pump:           { w: 2, h: 2, name: '–ù–∞—Å–æ—Å',         color: '#2d4a5a', outputSide: 'any' }
    };

    // Recipe database: what each facility can produce
    const RECIPES = {
        furnace: {
            'ferrite': { input: ['ferrite_ore'], output: 'ferrite', name: '–§–µ—Ä—Ä–∏–π' },
            'steel': { input: ['fine_ferrite'], output: 'steel', name: '–°—Ç–∞–ª—å' },
            'amethyst_fiber': { input: ['amethyst_ore'], output: 'amethyst_fiber', name: '–ê–º–µ—Ç–∏—Å—Ç–æ–≤–æ–µ –≤–æ–ª–æ–∫–Ω–æ' },
            'carbon': { input: ['sandleaf'], output: 'carbon', name: '–£–≥–ª–µ—Ä–æ–¥' }
        },
        grinder: {
            'ferrite_powder': { input: ['ferrite'], output: 'ferrite_powder', name: '–ú–æ–ª–æ—Ç—ã–π —Ñ–µ—Ä—Ä–∏–π' },
            'sandleaf_powder': { input: ['sandleaf'], output: 'sandleaf_powder', name: '–ú–æ–ª–æ—Ç—ã–π –ø–µ—Å—á–∞–Ω–æ–ª–∏—Å—Ç' },
            'amethyst_powder': { input: ['amethyst_fiber'], output: 'amethyst_powder', name: '–ú–æ–ª–æ—Ç—ã–π –∞–º–µ—Ç–∏—Å—Ç' }
        },
        thickener: {
            'fine_ferrite': { input: ['ferrite_powder', 'sandleaf_powder'], output: 'fine_ferrite', name: '–ú–µ–ª–∫–æ–º–æ–ª–æ—Ç—ã–π —Ñ–µ—Ä—Ä–∏–π' },
            'crystite_powder': { input: ['amethyst_powder', 'sandleaf_powder'], output: 'crystite_powder', name: '–ú–æ–ª–æ—Ç—ã–π –∫—Ä–∏—Å—Ç–æ–Ω' }
        },
        shaping: {
            'ferrite_bottle': { input: ['ferrite'], output: 'ferrite_bottle', name: '–§–µ—Ä—Ä–∏–µ–≤–∞—è –±—É—Ç—ã–ª–∫–∞' },
            'steel_bottle': { input: ['steel'], output: 'steel_bottle', name: '–°—Ç–∞–ª—å–Ω–∞—è –±—É—Ç—ã–ª–∫–∞' }
        },
        planter: {
            'sandleaf': { input: ['sandleaf_seed'], output: 'sandleaf', name: '–ü–µ—Å—á–∞–Ω–æ–ª–∏—Å—Ç' }
        },
        seed_collector: {
            'sandleaf_seed': { input: ['sandleaf'], output: 'sandleaf_seed', name: '–°–µ–º–µ–Ω–∞ –ø–µ—Å—á–∞–Ω–æ–ª–∏—Å—Ç–∞' }
        },
        storage: {
            'any': { input: ['any'], output: null, name: '–•—Ä–∞–Ω–∏–ª–∏—â–µ (–ª—é–±–æ–µ)' }
        }
    };

    // Resource names in Russian
    const RESOURCE_NAMES = {
        'ferrite_ore': '–§–µ—Ä—Ä–∏–µ–≤–∞—è —Ä—É–¥–∞',
        'ferrite': '–§–µ—Ä—Ä–∏–π',
        'ferrite_powder': '–ú–æ–ª–æ—Ç—ã–π —Ñ–µ—Ä—Ä–∏–π',
        'fine_ferrite': '–ú–µ–ª–∫–æ–º–æ–ª–æ—Ç—ã–π —Ñ–µ—Ä—Ä–∏–π',
        'steel': '–°—Ç–∞–ª—å',
        'sandleaf': '–ü–µ—Å—á–∞–Ω–æ–ª–∏—Å—Ç',
        'sandleaf_seed': '–°–µ–º–µ–Ω–∞ –ø–µ—Å—á–∞–Ω–æ–ª–∏—Å—Ç–∞',
        'sandleaf_powder': '–ú–æ–ª–æ—Ç—ã–π –ø–µ—Å—á–∞–Ω–æ–ª–∏—Å—Ç',
        'amethyst_ore': '–ê–º–µ—Ç–∏—Å—Ç–æ–≤–∞—è —Ä—É–¥–∞',
        'amethyst_fiber': '–ê–º–µ—Ç–∏—Å—Ç–æ–≤–æ–µ –≤–æ–ª–æ–∫–Ω–æ',
        'amethyst_powder': '–ú–æ–ª–æ—Ç—ã–π –∞–º–µ—Ç–∏—Å—Ç',
        'crystite_powder': '–ú–æ–ª–æ—Ç—ã–π –∫—Ä–∏—Å—Ç–æ–Ω',
        'carbon': '–£–≥–ª–µ—Ä–æ–¥',
        'ferrite_bottle': '–§–µ—Ä—Ä–∏–µ–≤–∞—è –±—É—Ç—ã–ª–∫–∞',
        'steel_bottle': '–°—Ç–∞–ª—å–Ω–∞—è –±—É—Ç—ã–ª–∫–∞'
    };

    // === STATE ===
    let zoom = 1;
    let cellSize = BASE_CELL_SIZE;
    let currentTool = 'select';
    let currentRotation = 0; // 0, 1, 2, 3 = 0¬∞, 90¬∞, 180¬∞, 270¬∞
    let facilities = [];
    let conveyors = []; // [{x, y, dir}]
    let undoStack = [];
    let redoStack = [];
    let isDrawing = false;
    let lastDrawPos = null;

    // Rotate a side by rotation steps (clockwise)
    function rotateSide(side, rotation) {
        if (!side || side === 'any') return side;
        const sides = ['top', 'right', 'bottom', 'left'];
        const idx = sides.indexOf(side);
        if (idx === -1) return side;
        return sides[(idx + rotation) % 4];
    }

    // Get effective input/output sides for a facility considering rotation
    function getEffectiveSides(def, rotation = 0) {
        return {
            inputSide: rotateSide(def.inputSide, rotation),
            outputSide: rotateSide(def.outputSide, rotation)
        };
    }

    // === CANVAS SETUP ===
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('container');

    function resizeCanvas() {
        const size = GRID_SIZE * cellSize;
        canvas.width = size;
        canvas.height = size;
        render();
    }

    // === RENDERING ===
    function render() {
        const size = GRID_SIZE * cellSize;
        ctx.clearRect(0, 0, size, size);

        // Background
        ctx.fillStyle = '#1e2a4a';
        ctx.fillRect(0, 0, size, size);

        // Grid lines
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cellSize, 0);
            ctx.lineTo(i * cellSize, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i * cellSize);
            ctx.lineTo(size, i * cellSize);
            ctx.stroke();
        }

        // Output zones (green areas on edges) with center dots
        for (let i = 0; i < GRID_SIZE; i += 3) {
            const centerOffset = 1; // —Ü–µ–Ω—Ç—Ä –∏–∑ 3 —Ç–∞–π–ª–æ–≤ (0, 1, 2)

            // Top edge - 3 —Ç–∞–π–ª–∞ —à–∏—Ä–∏–Ω–æ–π, –≤—ã—Ö–æ–¥ –ø–æ —Ü–µ–Ω—Ç—Ä—É
            ctx.fillStyle = 'rgba(30, 100, 30, 0.2)';
            ctx.fillRect(i * cellSize, 0, 3 * cellSize, cellSize);
            // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –≤—ã—Ö–æ–¥–∞ (—Å–≤–µ—Ä—Ö—É)
            ctx.fillStyle = '#4f4';
            ctx.beginPath();
            ctx.arc((i + centerOffset) * cellSize + cellSize/2, cellSize/2, cellSize * 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Connection zone (1 tile below edge output)
            ctx.fillStyle = 'rgba(0, 200, 0, 0.25)';
            ctx.fillRect((i + centerOffset) * cellSize, 1 * cellSize, cellSize, cellSize);

            // Left edge - 3 —Ç–∞–π–ª–∞ –≤—ã—Å–æ—Ç–æ–π, –≤—ã—Ö–æ–¥ –ø–æ —Ü–µ–Ω—Ç—Ä—É (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º —É–≥–æ–ª i=0)
            if (i > 0) {
                ctx.fillStyle = 'rgba(30, 100, 30, 0.2)';
                ctx.fillRect(0, i * cellSize, cellSize, 3 * cellSize);
                ctx.fillStyle = '#4f4';
                ctx.beginPath();
                ctx.arc(cellSize/2, (i + centerOffset) * cellSize + cellSize/2, cellSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Connection zone (1 tile right of edge output)
                ctx.fillStyle = 'rgba(0, 200, 0, 0.25)';
                ctx.fillRect(1 * cellSize, (i + centerOffset) * cellSize, cellSize, cellSize);
            }
        }

        // Conveyors
        for (const c of conveyors) {
            drawConveyor(c.x, c.y, c.dir);
        }

        // Facilities
        for (const f of facilities) {
            drawFacility(f);
        }

        // Tile flags overlay
        drawTileFlags();

        // Preview (current tool)
        if (currentTool !== 'select' && currentTool !== 'conveyor' && hoverPos) {
            drawPreview(hoverPos.x, hoverPos.y);
        }

        updateStats();
    }

    function drawConveyor(x, y, dir) {
        const cx = x * cellSize + cellSize / 2;
        const cy = y * cellSize + cellSize / 2;
        const s = cellSize * 0.3;

        ctx.fillStyle = '#666';
        ctx.fillRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);

        // Arrow
        ctx.fillStyle = '#ffa';
        ctx.beginPath();
        switch(dir) {
            case 'r': ctx.moveTo(cx-s, cy-s); ctx.lineTo(cx+s, cy); ctx.lineTo(cx-s, cy+s); break;
            case 'l': ctx.moveTo(cx+s, cy-s); ctx.lineTo(cx-s, cy); ctx.lineTo(cx+s, cy+s); break;
            case 'd': ctx.moveTo(cx-s, cy-s); ctx.lineTo(cx, cy+s); ctx.lineTo(cx+s, cy-s); break;
            case 'u': ctx.moveTo(cx-s, cy+s); ctx.lineTo(cx, cy-s); ctx.lineTo(cx+s, cy+s); break;
        }
        ctx.fill();
    }

    function drawFacility(f) {
        const def = FACILITIES[f.type];
        const rotation = f.rotation || 0;
        const { inputSide, outputSide } = getEffectiveSides(def, rotation);
        const x = f.x * cellSize;
        const y = f.y * cellSize;
        const w = def.w * cellSize;
        const h = def.h * cellSize;

        // Body
        ctx.fillStyle = def.color;
        ctx.fillRect(x, y, w, h);

        // Draw input/output zones as colored cells
        const dotRadius = cellSize * 0.25;

        // Input side (yellow/orange)
        if (inputSide === 'left') {
            for (let i = 0; i < def.h; i++) {
                ctx.fillStyle = 'rgba(255, 180, 0, 0.4)';
                ctx.fillRect(x, y + i * cellSize, cellSize, cellSize);
                ctx.fillStyle = '#fa0';
                ctx.beginPath();
                ctx.arc(x + cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (inputSide === 'top') {
            for (let i = 0; i < def.w; i++) {
                ctx.fillStyle = 'rgba(255, 180, 0, 0.4)';
                ctx.fillRect(x + i * cellSize, y, cellSize, cellSize);
                ctx.fillStyle = '#fa0';
                ctx.beginPath();
                ctx.arc(x + i * cellSize + cellSize/2, y + cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (inputSide === 'right') {
            for (let i = 0; i < def.h; i++) {
                ctx.fillStyle = 'rgba(255, 180, 0, 0.4)';
                ctx.fillRect(x + w - cellSize, y + i * cellSize, cellSize, cellSize);
                ctx.fillStyle = '#fa0';
                ctx.beginPath();
                ctx.arc(x + w - cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (inputSide === 'bottom') {
            for (let i = 0; i < def.w; i++) {
                ctx.fillStyle = 'rgba(255, 180, 0, 0.4)';
                ctx.fillRect(x + i * cellSize, y + h - cellSize, cellSize, cellSize);
                ctx.fillStyle = '#fa0';
                ctx.beginPath();
                ctx.arc(x + i * cellSize + cellSize/2, y + h - cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (inputSide === 'any') {
            // Storage - –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã –≤—Ö–æ–¥ (–∂—ë–ª—Ç—ã–µ —Ç–æ—á–∫–∏ –ø–æ –ø–µ—Ä–∏–º–µ—Ç—Ä—É)
            ctx.fillStyle = '#fa0';
            for (let i = 0; i < def.w; i++) {
                ctx.beginPath(); ctx.arc(x + i * cellSize + cellSize/2, y + cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + i * cellSize + cellSize/2, y + h - cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
            }
            for (let i = 1; i < def.h - 1; i++) {
                ctx.beginPath(); ctx.arc(x + cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + w - cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
            }
        }

        // Output side (green)
        if (outputSide === 'right') {
            for (let i = 0; i < def.h; i++) {
                ctx.fillStyle = 'rgba(0, 200, 0, 0.4)';
                ctx.fillRect(x + w - cellSize, y + i * cellSize, cellSize, cellSize);
                ctx.fillStyle = '#0c0';
                ctx.beginPath();
                ctx.arc(x + w - cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (outputSide === 'bottom') {
            for (let i = 0; i < def.w; i++) {
                ctx.fillStyle = 'rgba(0, 200, 0, 0.4)';
                ctx.fillRect(x + i * cellSize, y + h - cellSize, cellSize, cellSize);
                ctx.fillStyle = '#0c0';
                ctx.beginPath();
                ctx.arc(x + i * cellSize + cellSize/2, y + h - cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (outputSide === 'left') {
            for (let i = 0; i < def.h; i++) {
                ctx.fillStyle = 'rgba(0, 200, 0, 0.4)';
                ctx.fillRect(x, y + i * cellSize, cellSize, cellSize);
                ctx.fillStyle = '#0c0';
                ctx.beginPath();
                ctx.arc(x + cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (outputSide === 'top') {
            for (let i = 0; i < def.w; i++) {
                ctx.fillStyle = 'rgba(0, 200, 0, 0.4)';
                ctx.fillRect(x + i * cellSize, y, cellSize, cellSize);
                ctx.fillStyle = '#0c0';
                ctx.beginPath();
                ctx.arc(x + i * cellSize + cellSize/2, y + cellSize/2, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (outputSide === 'any') {
            // Drill/Pump - –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã –≤—ã—Ö–æ–¥ (–∑–µ–ª—ë–Ω—ã–µ —Ç–æ—á–∫–∏ –ø–æ –ø–µ—Ä–∏–º–µ—Ç—Ä—É)
            ctx.fillStyle = '#0c0';
            for (let i = 0; i < def.w; i++) {
                ctx.beginPath(); ctx.arc(x + i * cellSize + cellSize/2, y + cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + i * cellSize + cellSize/2, y + h - cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
            }
            for (let i = 1; i < def.h - 1; i++) {
                ctx.beginPath(); ctx.arc(x + cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + w - cellSize/2, y + i * cellSize + cellSize/2, dotRadius, 0, Math.PI * 2); ctx.fill();
            }
        }

        // Border
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);

        // Name
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.font = `${Math.max(8, cellSize * 0.8)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(def.name, x + w/2, y + h/2);

        // Draw CONNECTION ZONES (1 tile OUTSIDE the facility)
        const zoneAlpha = 0.25;

        // Input connection zone (orange) - where conveyors should ENTER
        if (inputSide === 'left') {
            ctx.fillStyle = `rgba(255, 150, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.h; i++) {
                ctx.fillRect((f.x - 1) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
            }
        } else if (inputSide === 'top') {
            ctx.fillStyle = `rgba(255, 150, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.w; i++) {
                ctx.fillRect((f.x + i) * cellSize, (f.y - 1) * cellSize, cellSize, cellSize);
            }
        } else if (inputSide === 'right') {
            ctx.fillStyle = `rgba(255, 150, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.h; i++) {
                ctx.fillRect((f.x + def.w) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
            }
        } else if (inputSide === 'bottom') {
            ctx.fillStyle = `rgba(255, 150, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.w; i++) {
                ctx.fillRect((f.x + i) * cellSize, (f.y + def.h) * cellSize, cellSize, cellSize);
            }
        } else if (inputSide === 'any') {
            ctx.fillStyle = `rgba(255, 150, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.w; i++) {
                ctx.fillRect((f.x + i) * cellSize, (f.y - 1) * cellSize, cellSize, cellSize);
                ctx.fillRect((f.x + i) * cellSize, (f.y + def.h) * cellSize, cellSize, cellSize);
            }
            for (let i = 0; i < def.h; i++) {
                ctx.fillRect((f.x - 1) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
                ctx.fillRect((f.x + def.w) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
            }
        }

        // Output connection zone (green) - where conveyors should EXIT FROM
        if (outputSide === 'right') {
            ctx.fillStyle = `rgba(0, 200, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.h; i++) {
                ctx.fillRect((f.x + def.w) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
            }
        } else if (outputSide === 'bottom') {
            ctx.fillStyle = `rgba(0, 200, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.w; i++) {
                ctx.fillRect((f.x + i) * cellSize, (f.y + def.h) * cellSize, cellSize, cellSize);
            }
        } else if (outputSide === 'left') {
            ctx.fillStyle = `rgba(0, 200, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.h; i++) {
                ctx.fillRect((f.x - 1) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
            }
        } else if (outputSide === 'top') {
            ctx.fillStyle = `rgba(0, 200, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.w; i++) {
                ctx.fillRect((f.x + i) * cellSize, (f.y - 1) * cellSize, cellSize, cellSize);
            }
        } else if (outputSide === 'any') {
            ctx.fillStyle = `rgba(0, 200, 0, ${zoneAlpha})`;
            for (let i = 0; i < def.w; i++) {
                ctx.fillRect((f.x + i) * cellSize, (f.y - 1) * cellSize, cellSize, cellSize);
                ctx.fillRect((f.x + i) * cellSize, (f.y + def.h) * cellSize, cellSize, cellSize);
            }
            for (let i = 0; i < def.h; i++) {
                ctx.fillRect((f.x - 1) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
                ctx.fillRect((f.x + def.w) * cellSize, (f.y + i) * cellSize, cellSize, cellSize);
            }
        }

        // Pylon coverage area (12x12 centered on 2x2 pylon)
        if (f.type === 'pylon' && def.coverage) {
            const coverage = def.coverage;
            // Center of 2x2 pylon
            const centerX = f.x + 1;
            const centerY = f.y + 1;
            // Coverage zone boundaries (clipped to grid)
            const covX1 = Math.max(0, centerX - coverage / 2);
            const covY1 = Math.max(0, centerY - coverage / 2);
            const covX2 = Math.min(GRID_SIZE, centerX + coverage / 2);
            const covY2 = Math.min(GRID_SIZE, centerY + coverage / 2);

            // Draw filled zone with low opacity
            ctx.fillStyle = 'rgba(180, 80, 180, 0.15)';
            ctx.fillRect(covX1 * cellSize, covY1 * cellSize, (covX2 - covX1) * cellSize, (covY2 - covY1) * cellSize);

            // Draw dashed border
            ctx.strokeStyle = 'rgba(200, 80, 200, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.strokeRect(covX1 * cellSize, covY1 * cellSize, (covX2 - covX1) * cellSize, (covY2 - covY1) * cellSize);
            ctx.setLineDash([]);
            ctx.lineWidth = 1;
        }
    }

    let hoverPos = null;
    let lastValidation = null;

    function drawPreview(x, y) {
        const def = FACILITIES[currentTool];
        if (!def) return;

        const validation = validatePlacement(x, y, currentTool);
        lastValidation = validation;
        const canPlace = validation.valid;
        const px = x * cellSize;
        const py = y * cellSize;
        const pw = def.w * cellSize;
        const ph = def.h * cellSize;

        ctx.fillStyle = canPlace ? 'rgba(79, 195, 247, 0.3)' : 'rgba(244, 67, 54, 0.3)';
        ctx.fillRect(px, py, pw, ph);
        ctx.strokeStyle = canPlace ? '#4fc3f7' : '#f44336';
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(px, py, pw, ph);
        ctx.setLineDash([]);

        if (!canPlace && validation.overlappedConveyors.length > 0) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
            for (const c of validation.overlappedConveyors) {
                ctx.fillRect(c.x * cellSize, c.y * cellSize, cellSize, cellSize);
            }
        }

        if (canPlace) {
            showValidationMessage('');
        } else {
            showValidationMessage(validation.errors.join(' | '), true);
        }

        // Show rotated I/O in preview
        const { inputSide, outputSide } = getEffectiveSides(def, currentRotation);
        const dotRadius = cellSize * 0.2;

        // Input indicator (yellow)
        ctx.fillStyle = 'rgba(255, 180, 0, 0.8)';
        if (inputSide === 'left') ctx.fillRect(px, py, cellSize * 0.3, ph);
        else if (inputSide === 'right') ctx.fillRect(px + pw - cellSize * 0.3, py, cellSize * 0.3, ph);
        else if (inputSide === 'top') ctx.fillRect(px, py, pw, cellSize * 0.3);
        else if (inputSide === 'bottom') ctx.fillRect(px, py + ph - cellSize * 0.3, pw, cellSize * 0.3);

        // Output indicator (green)
        ctx.fillStyle = 'rgba(0, 200, 0, 0.8)';
        if (outputSide === 'left') ctx.fillRect(px, py, cellSize * 0.3, ph);
        else if (outputSide === 'right') ctx.fillRect(px + pw - cellSize * 0.3, py, cellSize * 0.3, ph);
        else if (outputSide === 'top') ctx.fillRect(px, py, pw, cellSize * 0.3);
        else if (outputSide === 'bottom') ctx.fillRect(px, py + ph - cellSize * 0.3, pw, cellSize * 0.3);
    }

    // === PLACEMENT LOGIC ===
    function canPlaceFacility(x, y, w, h, excludeId = null) {
        if (x < 0 || y < 0 || x + w > GRID_SIZE || y + h > GRID_SIZE) return false;

        for (let dy = 0; dy < h; dy++) {
            for (let dx = 0; dx < w; dx++) {
                const cx = x + dx;
                const cy = y + dy;

                for (const f of facilities) {
                    if (excludeId && f.id === excludeId) continue;
                    const fd = FACILITIES[f.type];
                    if (cx >= f.x && cx < f.x + fd.w && cy >= f.y && cy < f.y + fd.h) {
                        return false;
                    }
                }

                if (conveyors.some(c => c.x === cx && c.y === cy)) {
                    return false;
                }
            }
        }
        return true;
    }

    function canPlaceConveyor(x, y) {
        if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;

        for (const f of facilities) {
            const fd = FACILITIES[f.type];
            if (x >= f.x && x < f.x + fd.w && y >= f.y && y < f.y + fd.h) {
                return false;
            }
        }

        return true;
    }

    function validatePlacement(x, y, type, excludeId = null) {
        const def = FACILITIES[type];
        const errors = [];
        const w = def.w;
        const h = def.h;

        if (x < 0 || y < 0 || x + w > GRID_SIZE || y + h > GRID_SIZE) {
            errors.push('–ó–∞ –≥—Ä–∞–Ω–∏—Ü–µ–π –∫–∞—Ä—Ç—ã');
        }

        const overlappedFacilities = [];
        const overlappedConveyors = [];

        for (let dy = 0; dy < h; dy++) {
            for (let dx = 0; dx < w; dx++) {
                const cx = x + dx;
                const cy = y + dy;

                for (const f of facilities) {
                    if (excludeId && f.id === excludeId) continue;
                    const fd = FACILITIES[f.type];
                    if (cx >= f.x && cx < f.x + fd.w && cy >= f.y && cy < f.y + fd.h) {
                        if (!overlappedFacilities.includes(fd.name)) {
                            overlappedFacilities.push(fd.name);
                        }
                    }
                }

                if (conveyors.some(c => c.x === cx && c.y === cy)) {
                    overlappedConveyors.push({ x: cx, y: cy });
                }
            }
        }

        if (overlappedFacilities.length > 0) {
            errors.push('–ü–µ—Ä–µ—Å–µ–∫–∞–µ—Ç: ' + overlappedFacilities.join(', '));
        }

        if (overlappedConveyors.length > 0) {
            errors.push('–ü–µ—Ä–µ—Å–µ–∫–∞–µ—Ç ' + overlappedConveyors.length + ' –∫–æ–Ω–≤–µ–π–µ—Ä(–æ–≤)');
        }

        return {
            valid: errors.length === 0,
            errors,
            overlappedConveyors
        };
    }

    function showValidationMessage(msg, isError = false) {
        const el = document.getElementById('validationMsg');
        el.textContent = msg;
        el.className = isError ? 'validation-error' : 'validation-ok';
    }

    function placeFacility(x, y, type) {
        const def = FACILITIES[type];

        if (def.isHub) {
            const hub = facilities.find(f => FACILITIES[f.type].isHub);
            if (hub) {
                const validation = validatePlacement(x, y, type, hub.id);
                if (!validation.valid) {
                    showValidationMessage(validation.errors.join(' | '), true);
                    return false;
                }
                saveState();
                hub.x = x;
                hub.y = y;
                showValidationMessage('–•–∞–± –ø–µ—Ä–µ–º–µ—â—ë–Ω', false);
                render();
                return true;
            }
        }

        const validation = validatePlacement(x, y, type);
        if (!validation.valid) {
            showValidationMessage(validation.errors.join(' | '), true);
            return false;
        }

        saveState();
        facilities.push({ type, x, y, id: Date.now(), rotation: currentRotation });
        showValidationMessage(def.name + ' —Ä–∞–∑–º–µ—â—ë–Ω', false);
        render();
        return true;
    }

    // Determine auto-direction for conveyor based on adjacent facilities/edges
    function getAutoDirection(x, y) {
        // Check edge output zones (resources come FROM edge INTO map)
        if (y === 0) return 'd'; // Top edge - go down
        if (x === 0) return 'r'; // Left edge - go right

        // Check adjacent facilities
        for (const f of facilities) {
            const def = FACILITIES[f.type];
            const { inputSide, outputSide } = getEffectiveSides(def, f.rotation || 0);
            if (!inputSide && !outputSide) continue;

            // Check if conveyor is adjacent to facility OUTPUT (conveyor goes AWAY)
            if (outputSide === 'right' && x === f.x + def.w && y >= f.y && y < f.y + def.h) {
                return 'r';
            }
            if (outputSide === 'bottom' && y === f.y + def.h && x >= f.x && x < f.x + def.w) {
                return 'd';
            }
            if (outputSide === 'left' && x === f.x - 1 && y >= f.y && y < f.y + def.h) {
                return 'l';
            }
            if (outputSide === 'top' && y === f.y - 1 && x >= f.x && x < f.x + def.w) {
                return 'u';
            }

            // Check if conveyor is adjacent to facility INPUT (conveyor goes TOWARD)
            if (inputSide === 'left' && x === f.x - 1 && y >= f.y && y < f.y + def.h) {
                return 'r';
            }
            if (inputSide === 'top' && y === f.y - 1 && x >= f.x && x < f.x + def.w) {
                return 'd';
            }
            if (inputSide === 'right' && x === f.x + def.w && y >= f.y && y < f.y + def.h) {
                return 'l';
            }
            if (inputSide === 'bottom' && y === f.y + def.h && x >= f.x && x < f.x + def.w) {
                return 'u';
            }

            // Storage (any side = input) - point toward storage
            if (inputSide === 'any') {
                if (x === f.x - 1 && y >= f.y && y < f.y + def.h) return 'r';
                if (x === f.x + def.w && y >= f.y && y < f.y + def.h) return 'l';
                if (y === f.y - 1 && x >= f.x && x < f.x + def.w) return 'd';
                if (y === f.y + def.h && x >= f.x && x < f.x + def.w) return 'u';
            }

            // Drill/Pump (any side = output) - point away
            if (outputSide === 'any') {
                if (x === f.x - 1 && y >= f.y && y < f.y + def.h) return 'l';
                if (x === f.x + def.w && y >= f.y && y < f.y + def.h) return 'r';
                if (y === f.y - 1 && x >= f.x && x < f.x + def.w) return 'u';
                if (y === f.y + def.h && x >= f.x && x < f.x + def.w) return 'd';
            }
        }

        return null; // No auto-direction
    }

    function placeConveyor(x, y, dir) {
        if (!canPlaceConveyor(x, y)) return false;

        // Try auto-direction first
        const autoDir = getAutoDirection(x, y);
        const finalDir = autoDir || dir;

        // Remove existing conveyor at position
        conveyors = conveyors.filter(c => !(c.x === x && c.y === y));
        conveyors.push({ x, y, dir: finalDir });
        render();
        return true;
    }

    function removeAt(x, y) {
        saveState();

        // Remove conveyor
        const convIdx = conveyors.findIndex(c => c.x === x && c.y === y);
        if (convIdx >= 0) {
            conveyors.splice(convIdx, 1);
            render();
            return;
        }

        // Remove facility (but not hub!)
        for (let i = facilities.length - 1; i >= 0; i--) {
            const f = facilities[i];
            const fd = FACILITIES[f.type];
            if (x >= f.x && x < f.x + fd.w && y >= f.y && y < f.y + fd.h) {
                if (fd.isHub) return;
                facilities.splice(i, 1);
                render();
                return;
            }
        }
    }

    // === UNDO/REDO ===
    function saveState() {
        undoStack.push(JSON.stringify({ facilities, conveyors }));
        if (undoStack.length > 50) undoStack.shift();
        redoStack = [];
    }

    function undo() {
        if (undoStack.length === 0) return;
        redoStack.push(JSON.stringify({ facilities, conveyors }));
        const state = JSON.parse(undoStack.pop());
        facilities = state.facilities;
        conveyors = state.conveyors;
        render();
    }

    function redo() {
        if (redoStack.length === 0) return;
        undoStack.push(JSON.stringify({ facilities, conveyors }));
        const state = JSON.parse(redoStack.pop());
        facilities = state.facilities;
        conveyors = state.conveyors;
        render();
    }

    // === ZOOM ===
    function zoomIn() {
        zoom = Math.min(3, zoom + 0.25);
        cellSize = BASE_CELL_SIZE * zoom;
        document.getElementById('zoomLabel').textContent = Math.round(zoom * 100) + '%';
        resizeCanvas();
    }

    function zoomOut() {
        zoom = Math.max(0.5, zoom - 0.25);
        cellSize = BASE_CELL_SIZE * zoom;
        document.getElementById('zoomLabel').textContent = Math.round(zoom * 100) + '%';
        resizeCanvas();
    }

    // === CLEAR ===
    function clearAll() {
        if (!confirm('–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë?')) return;
        saveState();
        const hub = facilities.find(f => FACILITIES[f.type].isHub);
        facilities = hub ? [hub] : [];
        conveyors = [];
        render();
    }

    // === EXPORT/IMPORT ===
    function exportJSON() {
        const name = prompt('–ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ö–µ–º—ã:', '–ú–æ—è —Ñ–∞–±—Ä–∏–∫–∞');
        if (!name) return;

        const data = {
            name,
            author: 'User',
            date: new Date().toISOString().split('T')[0],
            facilities: facilities.map(f => ({ type: f.type, x: f.x, y: f.y, rotation: f.rotation || 0 })),
            conveyors
        };

        const json = JSON.stringify(data, null, 2);
        const filename = name.replace(/\s+/g, '_').toLowerCase() + '.json';

        // –°–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);

        // –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä
        navigator.clipboard.writeText(json).then(() => {
            alert(`–°—Ö–µ–º–∞ "${name}" —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n–§–∞–π–ª: ${filename}\nJSON —Ç–∞–∫–∂–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞.\n\n–û—Ç–ø—Ä–∞–≤—å —Ñ–∞–π–ª –†–∞–º–∏–ª—é –¥–ª—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏ —Å—Ö–µ–º!`);
        }).catch(() => {
            alert(`–°—Ö–µ–º–∞ "${name}" —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n–§–∞–π–ª: ${filename}\n\n–û—Ç–ø—Ä–∞–≤—å —Ñ–∞–π–ª –†–∞–º–∏–ª—é –¥–ª—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏ —Å—Ö–µ–º!`);
        });
    }

    function importJSON() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const data = JSON.parse(event.target.result);
                    saveState();
                    facilities = data.facilities.map(f => ({ ...f, id: Date.now() + Math.random(), rotation: f.rotation || 0 }));
                    conveyors = data.conveyors || [];
                    render();
                    showValidationMessage('–ó–∞–≥—Ä—É–∂–µ–Ω–æ: ' + data.name, false);
                } catch (err) {
                    showValidationMessage('–û—à–∏–±–∫–∞: ' + err.message, true);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    // === TILE FLAGS SYSTEM ===
    // –§–ª–∞–≥–∏: F=Facility, C=Conveyor, I=Input, O=Output, P=Pylon-OK
    let showTileFlags = false;

    function getTileFlags(x, y) {
        let flags = [];

        // Check facilities
        for (const f of facilities) {
            const def = FACILITIES[f.type];
            const rotation = f.rotation || 0;
            const { inputSide, outputSide } = getEffectiveSides(def, rotation);

            // Inside facility?
            if (x >= f.x && x < f.x + def.w && y >= f.y && y < f.y + def.h) {
                flags.push('F');
            }

            // Input zone (1 tile outside)
            if (inputSide === 'left' && x === f.x - 1 && y >= f.y && y < f.y + def.h) flags.push('I');
            if (inputSide === 'right' && x === f.x + def.w && y >= f.y && y < f.y + def.h) flags.push('I');
            if (inputSide === 'top' && y === f.y - 1 && x >= f.x && x < f.x + def.w) flags.push('I');
            if (inputSide === 'bottom' && y === f.y + def.h && x >= f.x && x < f.x + def.w) flags.push('I');

            // Output zone (1 tile outside)
            if (outputSide === 'left' && x === f.x - 1 && y >= f.y && y < f.y + def.h) flags.push('O');
            if (outputSide === 'right' && x === f.x + def.w && y >= f.y && y < f.y + def.h) flags.push('O');
            if (outputSide === 'top' && y === f.y - 1 && x >= f.x && x < f.x + def.w) flags.push('O');
            if (outputSide === 'bottom' && y === f.y + def.h && x >= f.x && x < f.x + def.w) flags.push('O');
        }

        // Check conveyors
        if (conveyors.some(c => c.x === x && c.y === y)) {
            flags.push('C');
        }

        // Pylon-safe = no F and no C
        if (!flags.includes('F') && !flags.includes('C')) {
            flags.push('P');
        }

        return [...new Set(flags)]; // unique
    }

    function drawTileFlags() {
        if (!showTileFlags) return;

        ctx.font = `${Math.max(6, cellSize * 0.5)}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Only draw in visible area around facilities
        let minX = 60, maxX = 0, minY = 60, maxY = 0;
        for (const f of facilities) {
            const def = FACILITIES[f.type];
            minX = Math.min(minX, f.x - 2);
            minY = Math.min(minY, f.y - 2);
            maxX = Math.max(maxX, f.x + def.w + 2);
            maxY = Math.max(maxY, f.y + def.h + 2);
        }

        for (let y = Math.max(0, minY); y < Math.min(60, maxY); y++) {
            for (let x = Math.max(0, minX); x < Math.min(60, maxX); x++) {
                const flags = getTileFlags(x, y);
                if (flags.length === 0 || (flags.length === 1 && flags[0] === 'P')) continue;

                const cx = x * cellSize + cellSize / 2;
                const cy = y * cellSize + cellSize / 2;

                // Background
                ctx.fillStyle = flags.includes('P') ? 'rgba(0,255,0,0.3)' : 'rgba(255,0,0,0.3)';
                ctx.fillRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);

                // Code text
                ctx.fillStyle = '#fff';
                ctx.fillText(flags.filter(f => f !== 'P').join(''), cx, cy);
            }
        }
    }

    function toggleTileFlags() {
        showTileFlags = !showTileFlags;
        document.getElementById('flagsBtn').textContent = showTileFlags ? 'üè∑Ô∏è –ö–æ–¥—ã: –í–ö–õ' : 'üè∑Ô∏è –ö–æ–¥—ã';
        render();
    }

    // === VALIDATION SYSTEM ===
    function runValidation() {
        const errors = [];
        const warnings = [];

        // 1. Check facility overlaps
        for (let i = 0; i < facilities.length; i++) {
            const f1 = facilities[i];
            const def1 = FACILITIES[f1.type];
            for (let j = i + 1; j < facilities.length; j++) {
                const f2 = facilities[j];
                const def2 = FACILITIES[f2.type];
                if (rectsOverlap(f1.x, f1.y, def1.w, def1.h, f2.x, f2.y, def2.w, def2.h)) {
                    errors.push(`‚ùå –ü–ï–†–ï–°–ï–ß–ï–ù–ò–ï: ${f1.type} (${f1.x},${f1.y}) –∏ ${f2.type} (${f2.x},${f2.y})`);
                }
            }
        }

        // 2. Check conveyors inside facilities
        for (const c of conveyors) {
            const flags = getTileFlags(c.x, c.y);
            if (flags.includes('F')) {
                errors.push(`‚ùå –ö–û–ù–í–ï–ô–ï–† –í–ù–£–¢–†–ò –°–¢–ê–ù–ö–ê: (${c.x},${c.y})`);
            }
        }

        // 3. Check pylon coverage
        const pylons = facilities.filter(f => f.type === 'pylon');
        const nonPylons = facilities.filter(f => f.type !== 'pylon' && f.type !== 'hub');

        for (const f of nonPylons) {
            const def = FACILITIES[f.type];
            let covered = false;
            for (const p of pylons) {
                const pDef = FACILITIES['pylon'];
                const centerX = p.x + 1;
                const centerY = p.y + 1;
                const coverage = pDef.coverage || 12;
                const covX1 = centerX - coverage / 2;
                const covY1 = centerY - coverage / 2;
                const covX2 = centerX + coverage / 2;
                const covY2 = centerY + coverage / 2;

                // Check if at least 1 tile of facility touches coverage
                if (f.x < covX2 && f.x + def.w > covX1 && f.y < covY2 && f.y + def.h > covY1) {
                    covered = true;
                    break;
                }
            }
            if (!covered) {
                errors.push(`‚ùå –ù–ï–¢ –ü–ò–¢–ê–ù–ò–Ø: ${f.type} (${f.x},${f.y}) –Ω–µ –ø–æ–∫—Ä—ã—Ç –ø–∏–ª–æ–Ω–æ–º`);
            }
        }

        // 4. Check pylons not on facilities or conveyors
        for (const p of pylons) {
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    const flags = getTileFlags(p.x + dx, p.y + dy);
                    if (flags.includes('F') && !(p.x + dx >= p.x && p.x + dx < p.x + 2 && p.y + dy >= p.y && p.y + dy < p.y + 2)) {
                        errors.push(`‚ùå –ü–ò–õ–û–ù –ù–ê –°–¢–ê–ù–ö–ï: (${p.x},${p.y})`);
                    }
                    if (flags.includes('C')) {
                        errors.push(`‚ùå –ü–ò–õ–û–ù –ù–ê –ö–û–ù–í–ï–ô–ï–†–ï: (${p.x},${p.y}) - –∫–æ–Ω–≤–µ–π–µ—Ä –Ω–∞ (${p.x+dx},${p.y+dy})`);
                    }
                }
            }
        }

        // 5. Check conveyor connections (most important!)
        for (const c of conveyors) {
            const flags = getTileFlags(c.x, c.y);

            // Conveyor should be in an I zone (entering facility) or O zone (leaving facility) or neither (transit)
            const isInInput = flags.includes('I');
            const isInOutput = flags.includes('O');

            // Check direction makes sense
            const nextX = c.dir === 'r' ? c.x + 1 : c.dir === 'l' ? c.x - 1 : c.x;
            const nextY = c.dir === 'd' ? c.y + 1 : c.dir === 'u' ? c.y - 1 : c.y;
            const nextFlags = getTileFlags(nextX, nextY);

            // If in OUTPUT zone, conveyor should point AWAY from facility
            if (isInOutput && !isInInput) {
                // Find which facility this output belongs to
                for (const f of facilities) {
                    const def = FACILITIES[f.type];
                    const rot = f.rotation || 0;
                    const { outputSide } = getEffectiveSides(def, rot);

                    let isThisOutput = false;
                    if (outputSide === 'right' && c.x === f.x + def.w && c.y >= f.y && c.y < f.y + def.h) isThisOutput = true;
                    if (outputSide === 'left' && c.x === f.x - 1 && c.y >= f.y && c.y < f.y + def.h) isThisOutput = true;
                    if (outputSide === 'bottom' && c.y === f.y + def.h && c.x >= f.x && c.x < f.x + def.w) isThisOutput = true;
                    if (outputSide === 'top' && c.y === f.y - 1 && c.x >= f.x && c.x < f.x + def.w) isThisOutput = true;

                    if (isThisOutput) {
                        // Check direction points away
                        let correctDir = null;
                        if (outputSide === 'right') correctDir = 'r';
                        if (outputSide === 'left') correctDir = 'l';
                        if (outputSide === 'bottom') correctDir = 'd';
                        if (outputSide === 'top') correctDir = 'u';

                        if (c.dir !== correctDir && !isInInput) {
                            warnings.push(`‚ö†Ô∏è –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï: –ö–æ–Ω–≤–µ–π–µ—Ä (${c.x},${c.y}) –≤ –≤—ã—Ö–æ–¥–µ ${f.type}, –Ω–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω '${c.dir}' –≤–º–µ—Å—Ç–æ '${correctDir}'`);
                        }
                    }
                }
            }

            // If in INPUT zone (and not also output), conveyor should point INTO facility
            if (isInInput && !isInOutput) {
                for (const f of facilities) {
                    const def = FACILITIES[f.type];
                    const rot = f.rotation || 0;
                    const { inputSide } = getEffectiveSides(def, rot);

                    let isThisInput = false;
                    if (inputSide === 'left' && c.x === f.x - 1 && c.y >= f.y && c.y < f.y + def.h) isThisInput = true;
                    if (inputSide === 'right' && c.x === f.x + def.w && c.y >= f.y && c.y < f.y + def.h) isThisInput = true;
                    if (inputSide === 'top' && c.y === f.y - 1 && c.x >= f.x && c.x < f.x + def.w) isThisInput = true;
                    if (inputSide === 'bottom' && c.y === f.y + def.h && c.x >= f.x && c.x < f.x + def.w) isThisInput = true;

                    if (isThisInput) {
                        let correctDir = null;
                        if (inputSide === 'left') correctDir = 'r';
                        if (inputSide === 'right') correctDir = 'l';
                        if (inputSide === 'top') correctDir = 'd';
                        if (inputSide === 'bottom') correctDir = 'u';

                        if (c.dir !== correctDir) {
                            warnings.push(`‚ö†Ô∏è –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï: –ö–æ–Ω–≤–µ–π–µ—Ä (${c.x},${c.y}) –≤–æ –≤—Ö–æ–¥–µ ${f.type}, –Ω–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω '${c.dir}' –≤–º–µ—Å—Ç–æ '${correctDir}'`);
                        }
                    }
                }
            }
        }

        // 6. Check for disconnected outputs (facilities with no conveyor in output zone)
        for (const f of nonPylons) {
            if (f.type === 'storage') continue; // Storage doesn't need output
            const def = FACILITIES[f.type];
            const rot = f.rotation || 0;
            const { outputSide } = getEffectiveSides(def, rot);

            if (!outputSide) continue;

            let hasOutputConveyor = false;
            if (outputSide === 'right') {
                for (let dy = 0; dy < def.h; dy++) {
                    if (conveyors.some(c => c.x === f.x + def.w && c.y === f.y + dy)) {
                        hasOutputConveyor = true;
                        break;
                    }
                }
            } else if (outputSide === 'left') {
                for (let dy = 0; dy < def.h; dy++) {
                    if (conveyors.some(c => c.x === f.x - 1 && c.y === f.y + dy)) {
                        hasOutputConveyor = true;
                        break;
                    }
                }
            } else if (outputSide === 'bottom') {
                for (let dx = 0; dx < def.w; dx++) {
                    if (conveyors.some(c => c.x === f.x + dx && c.y === f.y + def.h)) {
                        hasOutputConveyor = true;
                        break;
                    }
                }
            } else if (outputSide === 'top') {
                for (let dx = 0; dx < def.w; dx++) {
                    if (conveyors.some(c => c.x === f.x + dx && c.y === f.y - 1)) {
                        hasOutputConveyor = true;
                        break;
                    }
                }
            }

            if (!hasOutputConveyor) {
                warnings.push(`‚ö†Ô∏è –ù–ï–¢ –í–´–•–û–î–ê: ${f.type} (${f.x},${f.y}) - –Ω–µ—Ç –∫–æ–Ω–≤–µ–π–µ—Ä–∞ –≤ –∑–æ–Ω–µ –≤—ã—Ö–æ–¥–∞ (${outputSide})`);
            }
        }

        // 7. Check for disconnected inputs
        for (const f of nonPylons) {
            const def = FACILITIES[f.type];
            const rot = f.rotation || 0;
            const { inputSide } = getEffectiveSides(def, rot);

            if (!inputSide) continue;

            let hasInputConveyor = false;
            if (inputSide === 'left') {
                for (let dy = 0; dy < def.h; dy++) {
                    if (conveyors.some(c => c.x === f.x - 1 && c.y === f.y + dy)) {
                        hasInputConveyor = true;
                        break;
                    }
                }
            } else if (inputSide === 'right') {
                for (let dy = 0; dy < def.h; dy++) {
                    if (conveyors.some(c => c.x === f.x + def.w && c.y === f.y + dy)) {
                        hasInputConveyor = true;
                        break;
                    }
                }
            } else if (inputSide === 'top') {
                for (let dx = 0; dx < def.w; dx++) {
                    if (conveyors.some(c => c.x === f.x + dx && c.y === f.y - 1)) {
                        hasInputConveyor = true;
                        break;
                    }
                }
            } else if (inputSide === 'bottom') {
                for (let dx = 0; dx < def.w; dx++) {
                    if (conveyors.some(c => c.x === f.x + dx && c.y === f.y + def.h)) {
                        hasInputConveyor = true;
                        break;
                    }
                }
            }

            if (!hasInputConveyor) {
                warnings.push(`‚ö†Ô∏è –ù–ï–¢ –í–•–û–î–ê: ${f.type} (${f.x},${f.y}) - –Ω–µ—Ç –∫–æ–Ω–≤–µ–π–µ—Ä–∞ –≤ –∑–æ–Ω–µ –≤—Ö–æ–¥–∞ (${inputSide})`);
            }
        }

        // 8. Resource flow validation (if recipes specified)
        const facilitiesWithRecipes = nonPylons.filter(f => f.recipe);
        if (facilitiesWithRecipes.length > 0) {
            for (const f of facilitiesWithRecipes) {
                const recipes = RECIPES[f.type];
                if (!recipes) {
                    warnings.push(`‚ö†Ô∏è –†–ï–¶–ï–ü–¢–´: ${f.type} –Ω–µ –∏–º–µ–µ—Ç —Ä–µ—Ü–µ–ø—Ç–æ–≤ –≤ –±–∞–∑–µ`);
                    continue;
                }
                const recipe = recipes[f.recipe];
                if (!recipe) {
                    errors.push(`‚ùå –†–ï–¶–ï–ü–¢: ${f.type} (${f.x},${f.y}) - –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç "${f.recipe}"`);
                    continue;
                }

                // Display what this facility produces
                const inputNames = recipe.input.map(r => RESOURCE_NAMES[r] || r).join(' + ');
                const outputName = recipe.output ? (RESOURCE_NAMES[recipe.output] || recipe.output) : '–Ω–∏—á–µ–≥–æ';
                warnings.push(`‚ÑπÔ∏è –†–ï–°–£–†–°: ${f.type} (${f.x},${f.y}) [${f.recipe}]: ${inputNames} ‚Üí ${outputName}`);
            }
        }

        // 9. Check resource chain connections
        const resourceFlow = [];
        for (const f of facilitiesWithRecipes) {
            const recipes = RECIPES[f.type];
            if (!recipes || !recipes[f.recipe]) continue;
            const recipe = recipes[f.recipe];
            resourceFlow.push({
                facility: f,
                inputs: recipe.input,
                output: recipe.output
            });
        }

        // Check if outputs match inputs of connected facilities
        for (const flow of resourceFlow) {
            if (!flow.output) continue;

            // Find facilities that this one connects to (via conveyors)
            const def = FACILITIES[flow.facility.type];
            const rot = flow.facility.rotation || 0;
            const { outputSide } = getEffectiveSides(def, rot);

            // Get output zone coordinates
            let outputZone = [];
            if (outputSide === 'right') {
                for (let dy = 0; dy < def.h; dy++) {
                    outputZone.push({ x: flow.facility.x + def.w, y: flow.facility.y + dy });
                }
            } else if (outputSide === 'left') {
                for (let dy = 0; dy < def.h; dy++) {
                    outputZone.push({ x: flow.facility.x - 1, y: flow.facility.y + dy });
                }
            } else if (outputSide === 'bottom') {
                for (let dx = 0; dx < def.w; dx++) {
                    outputZone.push({ x: flow.facility.x + dx, y: flow.facility.y + def.h });
                }
            } else if (outputSide === 'top') {
                for (let dx = 0; dx < def.w; dx++) {
                    outputZone.push({ x: flow.facility.x + dx, y: flow.facility.y - 1 });
                }
            }

            // Find which facilities receive from this output (via conveyor path)
            for (const pos of outputZone) {
                const flags = getTileFlags(pos.x, pos.y);
                // If this is also an input zone (IO overlap), check the receiving facility
                if (flags.includes('I')) {
                    for (const other of resourceFlow) {
                        if (other === flow) continue;
                        const otherDef = FACILITIES[other.facility.type];
                        const otherRot = other.facility.rotation || 0;
                        const { inputSide: otherInputSide } = getEffectiveSides(otherDef, otherRot);

                        let isOtherInput = false;
                        if (otherInputSide === 'left' && pos.x === other.facility.x - 1 && pos.y >= other.facility.y && pos.y < other.facility.y + otherDef.h) isOtherInput = true;
                        if (otherInputSide === 'right' && pos.x === other.facility.x + otherDef.w && pos.y >= other.facility.y && pos.y < other.facility.y + otherDef.h) isOtherInput = true;
                        if (otherInputSide === 'top' && pos.y === other.facility.y - 1 && pos.x >= other.facility.x && pos.x < other.facility.x + otherDef.w) isOtherInput = true;
                        if (otherInputSide === 'bottom' && pos.y === other.facility.y + otherDef.h && pos.x >= other.facility.x && pos.x < other.facility.x + otherDef.w) isOtherInput = true;

                        if (isOtherInput) {
                            // Check if resource matches
                            if (!other.inputs.includes(flow.output) && !other.inputs.includes('any')) {
                                const outName = RESOURCE_NAMES[flow.output] || flow.output;
                                const inNames = other.inputs.map(r => RESOURCE_NAMES[r] || r).join('/');
                                errors.push(`‚ùå –ù–ï–°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–¨: ${flow.facility.type} –≤—ã–¥–∞—ë—Ç "${outName}", –Ω–æ ${other.facility.type} (${other.facility.x},${other.facility.y}) –æ–∂–∏–¥–∞–µ—Ç "${inNames}"`);
                            }
                        }
                    }
                }
            }
        }

        // Display results
        const panel = document.getElementById('validationPanel');
        const results = document.getElementById('validationResults');
        panel.style.display = 'block';

        if (errors.length === 0 && warnings.length === 0) {
            results.innerHTML = '<div style="color:#4f4;">‚úÖ –°—Ö–µ–º–∞ –≤–∞–ª–∏–¥–Ω–∞! –û—à–∏–±–æ–∫ –Ω–µ—Ç.</div>';
        } else {
            let html = '';
            if (errors.length > 0) {
                html += '<div style="color:#f44; margin-bottom:8px;"><b>–û–®–ò–ë–ö–ò (' + errors.length + '):</b></div>';
                html += errors.map(e => '<div style="color:#f88; padding-left:10px;">' + e + '</div>').join('');
            }
            if (warnings.length > 0) {
                html += '<div style="color:#fa0; margin-top:8px; margin-bottom:8px;"><b>–ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–Ø (' + warnings.length + '):</b></div>';
                html += warnings.map(w => '<div style="color:#fc8; padding-left:10px;">' + w + '</div>').join('');
            }
            results.innerHTML = html;
        }

        return { errors, warnings };
    }

    function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    // === STATS ===
    function updateStats() {
        const pylons = facilities.filter(f => f.type === 'pylon').length;
        const facs = facilities.filter(f => f.type !== 'pylon').length;

        let area = conveyors.length;
        for (const f of facilities) {
            const def = FACILITIES[f.type];
            area += def.w * def.h;
        }

        document.getElementById('statFacilities').textContent = facs;
        document.getElementById('statConveyors').textContent = conveyors.length;
        document.getElementById('statPylons').textContent = pylons;
        document.getElementById('statArea').textContent = area;
    }

    // === EVENT HANDLERS ===
    function getGridPos(e) {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / cellSize);
        const y = Math.floor((e.clientY - rect.top) / cellSize);
        return { x, y };
    }

    canvas.addEventListener('mousemove', e => {
        hoverPos = getGridPos(e);

        if (isDrawing && currentTool === 'conveyor') {
            const pos = hoverPos;
            if (!lastDrawPos || pos.x !== lastDrawPos.x || pos.y !== lastDrawPos.y) {
                // Determine direction based on movement
                let dir = 'r';
                if (lastDrawPos) {
                    if (pos.x > lastDrawPos.x) dir = 'r';
                    else if (pos.x < lastDrawPos.x) dir = 'l';
                    else if (pos.y > lastDrawPos.y) dir = 'd';
                    else if (pos.y < lastDrawPos.y) dir = 'u';
                }
                placeConveyor(pos.x, pos.y, dir);
                lastDrawPos = pos;
            }
        }

        render();
    });

    canvas.addEventListener('mousedown', e => {
        const pos = getGridPos(e);

        if (e.button === 0) { // Left click
            if (currentTool === 'select') {
                // Select mode - —É–¥–∞–ª–µ–Ω–∏–µ –ø–æ –õ–ö–ú
                removeAt(pos.x, pos.y);
            } else if (currentTool === 'conveyor') {
                saveState();
                isDrawing = true;
                lastDrawPos = pos;
                placeConveyor(pos.x, pos.y, 'r');
            } else {
                placeFacility(pos.x, pos.y, currentTool);
            }
        } else if (e.button === 2) { // Right click
            removeAt(pos.x, pos.y);
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDrawing = false;
        lastDrawPos = null;
    });

    canvas.addEventListener('mouseleave', () => {
        isDrawing = false;
        lastDrawPos = null;
        hoverPos = null;
        lastValidation = null;
        showValidationMessage('');
        render();
    });

    canvas.addEventListener('contextmenu', e => e.preventDefault());

    canvas.addEventListener('wheel', e => {
        if (e.ctrlKey) {
            e.preventDefault();
            if (e.deltaY < 0) zoomIn();
            else zoomOut();
        }
    });

    // Tool selection
    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentTool = btn.dataset.tool;
        });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
        if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
        if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
        if (e.key === 'Escape') {
            document.querySelector('[data-tool="select"]').click();
        }
        if (e.key === 'r' || e.key === 'R' || e.key === '–∫' || e.key === '–ö') {
            currentRotation = (currentRotation + 1) % 4;
            document.getElementById('rotationLabel').textContent = 'R: ' + (currentRotation * 90) + '¬∞';
            render();
        }
    });

    // Init - add hub in center
    const hubStart = Math.floor((GRID_SIZE - 9) / 2);
    facilities.push({ type: 'hub', x: hubStart, y: hubStart, id: 'hub' });
    resizeCanvas();
    </script>
</body>
</html>
